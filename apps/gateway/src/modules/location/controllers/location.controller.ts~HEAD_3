import {
  Body,
  Controller,
  Delete,
  Get,
  HttpStatus,
  Inject,
  Param,
  Post,
  Put,
  Query,
  Req,
  UploadedFile,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { ClientKafka } from '@nestjs/microservices';
import { FileInterceptor } from '@nestjs/platform-express';
import {
  ApiConsumes,
  ApiOAuth2,
  ApiOperation,
  ApiParam,
  ApiQuery,
  ApiTags,
} from '@nestjs/swagger';
import { isJSON } from 'class-validator';
import { diskStorage } from 'multer';
import { extname, parse } from 'path';

import { Account } from '@/account/models/account.model';
import { customSort, isJson } from '@/application/utils/JSON/json';
import { Authorization, CredentialAccount } from '@/decorators/auth.decorator';
import { GlobalResponse } from '@/dtos/response.dto';
import { OAuth2Guard } from '@/guards/oauth.guard';
import { LogOauthSignInService } from '@/logging/services/oauth/oauth.service';

import {
  ApiOperations,
  bucketAddDTO,
  bucketBulkDeleteQueryDTO,
  bucketDeleteParamDTO,
  bucketResDTO,
  bucketUpdateBodyDTO,
  bucketUpdateParamDTO,
} from '../attribute/bucket.api.helper';
import {
  LocationAddDTO,
  LocationAddDTOResponse,
  LocationBulkDTO,
} from '../dto/location.add.dto';
import { LocationEditDTO } from '../dto/location.edit.dto';
import { LocationImportDto } from '../dto/location.upload.dto';
import { LocationService } from '../services/location.service';

@Controller('location')
@ApiTags('Location Management')
@Controller('location')
export class LocationController {
  private locationService: LocationService;
  private logService: LogOauthSignInService;
  constructor(
    locationService: LocationService,
    logService: LogOauthSignInService,
    @Inject('LOCATION_SERVICE')
    private readonly clientLocationKafka: ClientKafka,
  ) {
    this.locationService = locationService;
    this.logService = logService;
  }

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiQuery({
    name: 'limit',
    type: Number,
    example: 10,
    description: 'Limit data to show',
    required: true,
  })
  @ApiQuery({
    name: 'skip',
    type: Number,
    example: 0,
    description: 'Offset',
    required: true,
  })
  @ApiQuery({
    name: 'filter',
    type: String,
    example: '{}',
    description:
      'You can define searching operator. ex: {"group_name":"%group_name_one%"}',
    required: false,
  })
  @ApiQuery({
    name: 'sort',
    type: String,
    example: '{}',
    description: 'Ex: {"group_name":-1}. 1 : Ascending, -1 : Descending',
    required: false,
  })
  @ApiOperation({
    summary: 'List all location',
    description:
      'Location (List of values) used to store all default value or selection collection that rarely changes',
  })
  @Get('tree')
  async index_tree(
    @Req() req,
    @Query('limit') limit: number,
    @Query('skip') skip: number,
    @Query('filter') filter: string,
    @Query('sort') sort: string,
    @CredentialAccount() account: Account,
  ) {
    return await this.locationService.getLocationTree({
      account: account,
      limit: limit,
      filter: filter,
      sort: sort,
      skip: skip,
    });
  }

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  // @ApiQuery({
  //   name: 'parent',
  //   type: String,
  //   example: '',
  // })
  @ApiQuery({
    name: 'type',
    type: String,
    example: '',
  })
  @ApiQuery({
    name: 'rebase',
    required: false,
    type: Boolean,
    example: true,
  })
  @ApiOperation({
    summary: 'List location tree using current credential data',
    description: `HQ - 62ffc0fc8a01008799e785bc<br />
    Area - 62ffc0fc8a01008799e785bd<br />
    Region - 62ffc0fc8a01008799e785be<br />
    Branch - 62ffc0fc8a01008799e785bf`,
  })
  @Get('loc_rebase')
  async index_rebase(
    // @Query('parent') parent: string,
    @Query('type') type: string,
    @Query('rebase') rebase: string,
    @CredentialAccount() account: any,
  ) {
    const location = account.account_location;
    // const location_type = account.account_location.location_detail.type;
    const location_iden = await this.locationService.detailLocation(
      location.location.toString(),
    );
    let selfMe = [];

    if (rebase === 'true') {
      if (type === location_iden.type.toString()) {
        selfMe.push(
          await this.locationService.detailLocation(
            location.location.toString(),
          ),
        );
      }
    } else {
      selfMe.push(
        await this.locationService.detailLocation(location.location.toString()),
      );
    }

    selfMe = selfMe.concat(
      await this.locationService.rebaseLocation(
        location.location.toString(),
        type,
      ),
    );

    const sorted = selfMe.sort(customSort('name'));

    return sorted;
  }

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiQuery({
    name: 'limit',
    type: Number,
    example: 10,
    description: 'Limit data to show',
    required: true,
  })
  @ApiQuery({
    name: 'skip',
    type: Number,
    example: 0,
    description: 'Offset',
    required: true,
  })
  @ApiQuery({
    name: 'filter',
    type: String,
    example: '{}',
    description:
      'You can define searching operator. ex: {"group_name":"%group_name_one%"}',
    required: false,
  })
  @ApiQuery({
    name: 'sort',
    type: String,
    example: '{}',
    description: 'Ex: {"group_name":-1}. 1 : Ascending, -1 : Descending',
    required: false,
  })
  @ApiOperation({
    summary: 'List all location',
    description:
      'Location (List of values) used to store all default value or selection collection that rarely changes',
  })
  @Get()
  async index(
    @Req() req,
    @Query('limit') limit: number,
    @Query('skip') skip: number,
    @Query('filter') filter: string,
    @Query('sort') sort: string,
  ) {
    return await this.locationService.getLocation({
      limit: limit,
      filter: filter,
      sort: sort,
      skip: skip,
    });
  }

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiOperation({
    summary: 'Add Location Item',
    description: 'group_name is used for grouping value',
  })
  @Post()
  async add(@Body() parameter: LocationAddDTO) {
    return await this.locationService.addLocation(parameter);
  }

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiOperation({
    summary: 'Add Bulk Location Item',
    description: 'Bulk data of location',
  })
  @Post('bulk')
  async add_bulk(
    @Body() parameter: LocationBulkDTO,
    @CredentialAccount() credential,
  ): Promise<LocationAddDTOResponse> {
    return await this.locationService.addLocationBulk(parameter, credential);
  }

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiParam({
    name: '_id',
  })
  @ApiOperation({
    summary: 'Edit Location Item',
    description: 'group_name is used for grouping value',
  })
  @Put(':_id/edit')
  async edit_customer(@Body() data: LocationEditDTO, @Param() param) {
    return await this.locationService.editLocation(data, param._id);
  }

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiParam({
    name: '_id',
  })
  @ApiOperation({
    summary: 'Delete Location Item',
    description: '',
  })
  @Delete(':_id/delete')
  async delete_customer(@Param() parameter) {
    return await this.locationService.deleteLocation(parameter._id);
  }

  @UseGuards(OAuth2Guard)
  @Authorization(false)
  @ApiOAuth2(['oauth2'])
  @ApiQuery({
    name: 'lazyEvent',
    type: String,
    example:
      '{"first":0,"rows":10,"sortField":"created_at","sortOrder":1,"filters":{}}',
    description: `Format: Prime default param<br />`,
    required: false,
  })
  @ApiOperation({
    summary: 'Show all program item',
    description: `<table>
    <tr>
      <td>
        first<br />
        <i>Offset of data</i>
      </td>
      <td>:</td>
      <td><b>number</b></td>
    </tr>
    <tr>
      <td>
      rows<br />
      <i>Limit data in page</i>
      </td>
      <td>:</td>
      <td><b>number</b></td>
      </tr>
    <tr>
      <td>
        sortField<br />
        <i>Field to be sort</i>
      </td>
      <td>:</td>
      <td><b>string</b></td>
    </tr>
    <tr>
      <td>
      sortOrder<br />
      <i>1 is ascending. -1 is descending</i>
      </td>
      <td>:</td>
      <td><b>number</b></td>
    </tr>
    <tr>
    <td>filters</td>
    <td>:</td>
    <td>
    <b>object</b><br />
    <table>
      <tr>
      <td>
      column_name_1<br />
      <i>Name of column to be searched</i>
      </td>
      <td>:</td>
      <td>
      <b>object</b>
      <table>
      <tr>
        <td>matchMode</td>
        <td>:</td>
        <td>
        <b>string</b><br />
        Only filled by following item:
        <ul>
          <li>
          <b>contains</b><br />
          Will search all data if column_name_1 contains the value
          <br />
          </li>
          <li>
          <b>notContains</b><br />
          Will search all data if column_name_1 not contains the value
          <br />
          </li>
          <li>
          <b>startsWith</b><br />
          Will search all data if column_name_1 starts with the value
          <br />
          </li>
          <li>
          <b>endsWith</b><br />
          Will search all data if column_name_1 ends with the value
          <br />
          </li>
          <li>
          <b>equals</b><br />
          Will search all data if column_name_1 equals to the value
          <br />
          </li>
          <li>
          <b>notEquals</b><br />
          Will search all data if column_name_1 not equals to the value
          <br />
          </li>
        </li>
        </td>
      </tr>
      <tr>
        <td>value</td>
        <td>:</td>
        <td><b>string</b></td>
      </tr>
      </table>
      </td>
      </tr>
      <tr>
      <td>
      column_name_2<br />
      <i>Name of column to be searched</i>
      </td>
      <td>:</td>
      <td>
      <b>object</b>
      <table>
      <tr>
        <td>matchMode</td>
        <td>:</td>
        <td>
        <b>string</b><br />
        Only filled by following item:
        <ul>
          <li>
          <b>contains</b><br />
          Will search all data if column_name_2 contains the value
          <br />
          </li>
          <li>
          <b>notContains</b><br />
          Will search all data if column_name_2 not contains the value
          <br />
          </li>
          <li>
          <b>startsWith</b><br />
          Will search all data if column_name_2 starts with the value
          <br />
          </li>
          <li>
          <b>endsWith</b><br />
          Will search all data if column_name_2 ends with the value
          <br />
          </li>
          <li>
          <b>equals</b><br />
          Will search all data if column_name_2 equals to the value
          <br />
          </li>
          <li>
          <b>notEquals</b><br />
          Will search all data if column_name_2 not equals to the value
          <br />
          </li>
        </li>
        </td>
      </tr>
      <tr>
        <td>value</td>
        <td>:</td>
        <td><b>string</b></td>
      </tr>
      </table>
      </td>
      </tr>
    </table>
    </td>
    </tr>
    </table>`,
  })
  @Get('prime')
  async getLocationPrimeTable(@Query('lazyEvent') parameter: string) {
    const lazyEvent = parameter;
    if (isJson(lazyEvent)) {
      const parsedData = JSON.parse(parameter);
      return await this.locationService.getLocationPrimeTable({
        first: parsedData.first,
        rows: parsedData.rows,
        sortField: parsedData.sortField,
        sortOrder: parsedData.sortOrder,
        filters: parsedData.filters,
      });
    } else {
      return {
        message: 'filters is not a valid json',
        payload: {},
      };
    }
  }

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  //@UseInterceptors(LoggingInterceptor)
  @ApiParam({
    name: '_id',
  })
  @ApiOperation({
    summary: 'Detail Location Item',
    description: '',
  })
  @Get(':_id/detail')
  async detail_customer(@Param() parameter) {
    return await this.locationService.detailLocation(parameter._id);
  }

  //=============================================================================BUCKET
  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiOperation(ApiOperations.BucketAdd)
  @Post('bucket')
  async add_bucket(
    @Body() data: bucketAddDTO,
    @CredentialAccount() credential: Account,
  ): Promise<bucketResDTO> {
    return await this.locationService.addBucket(data, credential);
  }

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiOperation(ApiOperations.BucketDelete)
  @Delete('bucket/:_id/delete')
  async deleteBucket(@Param() param: bucketDeleteParamDTO) {
    return await this.locationService.deleteBucket(param);
  }

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiOperation(ApiOperations.BucketDelete)
  @Delete('bucket/bulk-delete')
  async deleteBucketBulk(@Body() data: bucketBulkDeleteQueryDTO) {
    return await this.locationService.deleteBucketBulk(data);
  }

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiOperation(ApiOperations.BucketUpdate)
  @Put('bucket/:_id/edit')
  async editBucket(
    @Body() data: bucketUpdateBodyDTO,
    @Param() param: bucketUpdateParamDTO,
    @CredentialAccount() credential: Account,
  ) {
    return await this.locationService.editBucket(data, param, credential);
  }

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiOperation(ApiOperations.BucketReadPrime)
  @ApiQuery({
    name: 'lazyEvent',
    type: String,
    example: `{"first":0,"rows":10,"sortField":"created_at","sortOrder":1,"filters":{}}`,
    description: 'Format: Prime default param',
    required: false,
  })
  @Get('bucket-prime')
  async all(
    @Query('lazyEvent') parameter: string,
    @CredentialAccount() credential: Account,
  ) {
    const lazyEvent = parameter;
    if (isJSON(lazyEvent)) {
      const parsedData = JSON.parse(parameter);
      return await this.locationService.getBucketPrime(
        {
          first: parsedData.first,
          rows: parsedData.rows,
          sortField: parsedData.sortField,
          sortOrder: parsedData.sortOrder,
          filters: parsedData.filters,
        },
        credential,
      );
    } else {
      return {
        message: 'filters is not a valid json',
        payload: {},
      };
    }
  }

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiOperation(ApiOperations.BucketView)
  @Get('bucket/:_id/view')
  async viewBucket(@Param() param: bucketDeleteParamDTO) {
    return await this.locationService.viewBucket(param);
  }

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

  @UseGuards(OAuth2Guard)
  @Authorization(true)
  @ApiOAuth2(['oauth2'])
  @ApiOperation({
    summary: 'Import new Location item',
    description: 'Import new Location item',
  })
  @UseInterceptors(
    FileInterceptor('file', {
      dest: './uploads/location/',
      storage: diskStorage({
        destination: './uploads/location/',
        filename: (req, file, cb) => {
          const curr_date = new Date().toISOString().split('T');
          const time = curr_date[1].split('.')[0].replace(/:/g, '-');
          cb(null, `PRG_${curr_date[0]}_${time}${extname(file.originalname)}`);
        },
      }),
    }),
  )
  @ApiConsumes('multipart/form-data')
  @Post('import')
  async upload_msisdn_list(
    @CredentialAccount() credential,
    @Body() parameter: LocationImportDto,
    @UploadedFile() file: Express.Multer.File,
  ) {
    this.clientLocationKafka.emit('location', {
      credential: credential,
      file: file,
    });
    const response = new GlobalResponse();
    response.transaction_classify = 'LOCATION_IMPORT';
    response.message = 'Import Location successfully';
    response.statusCode = HttpStatus.OK;
    return response;
    // if (file) {
    //   return await this.locationService.import_location(
    //     credential,
    //     file
    //   )
    // } else {
    //   throw new Error('No file found');
    // }
  }
}
